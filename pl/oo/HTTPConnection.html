<html>
<head>
</head><BODY BACKGROUND="../../../../gfx/backs/ltbrush.gif">
<p><hr></p>
<a name=HTTPConnection><h2>Class HTTPConnection</h2></a>
<font face="Courier New,Courier">class HTTPConnection<br>extends  AsyncConnection</font>
<dl>
<dt><b>Documentation </b><dd>Klasa implementująca interfejs AsyncConnection i realizująca połączenie z
<dd>klientem (cześcią obiektu HTTPConnection jest obiekt AsyncSocket).
<dd>Zajmuje się tylko odbieraniem (i zapamiętywaniem) danych przesłanych od
<dd>klienta, oraz wysyłaniem odpowiedzi wygenerowanej przez obiekt
<dd>HTTPRequest. Obiekt tej klasy potrafi też wysłać plik wskazany przez
<dd>HTTPRequest'a.
</dl>
<h3><b>Links</h3></b>
<ul><li><b>Aggregation request to </b><a href=HTTPRequest.html#HTTPRequest>HTTPRequest</a></li></ul>
<dir><dt><b>Documentation </b>ten obiekt parsuje zapytanie przeglądarki i czyni odpowiedź
</dir>
<ul><li><b>Aggregation sock to </b><a href=AsyncSocket.html#AsyncSocket>AsyncSocket</a></li></ul>
<dir><dt><b>Documentation </b>socket - połączenie ze światem
</dir>
<ul><li><b>Association file to </b><a href=File.html#File>File</a></li></ul>
<dir><dt><b>Supplier cardinality </b>0..1</dt>
<dt><b>Documentation </b>Wskaźnik do pliku, który od czasu do czasu zdarzy się nam wysłać.
</dir>
<h3><b>Attributes</h3></b>
<a name=buffer#HTTPConnection><ul><li><b>buffer</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private char [bufferSize] buffer</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>bufor do odbierania i wysyłania danych
</dl>
</dir><a name=bufferSize#HTTPConnection><ul><li><b>bufferSize</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private static const size_t bufferSize</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>32k - powinno wystarczyć
</dl>
</dir><a name=finalized#HTTPConnection><ul><li><b>finalized</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private bool finalized</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>czy manager wie, że połączenie zakończone?
</dl>
</dir><a name=nread#HTTPConnection><ul><li><b>nread</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private size_t nread</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>ile już odebraliśmy/wysłaliśmy
</dl>
</dir><a name=nwritten#HTTPConnection><ul><li><b>nwritten</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private size_t nwritten</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>ile już odebraliśmy/wysłaliśmy
</dl>
</dir><a name=peer#HTTPConnection><ul><li><b>peer</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private struct sockaddr_in peer</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>tu zapamiętujemy adres klienta - w celu zapisu w logu
</dl>
</dir><a name=requestReceived#HTTPConnection><ul><li><b>requestReceived</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private bool requestReceived</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>czy odebraliśmy już kompletny request?
</dl>
</dir><a name=responseLength#HTTPConnection><ul><li><b>responseLength</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private size_t responseLength</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>ile trzeba będzie wysłać bajtów nagłówka
</dl>
</dir><h3><b>Operations</h3></b>
<a name=HTTPConnection#const_char_*#const_Properties_*#const_char_*#const_char_*#HTTPConnection><ul><li><b>HTTPConnection</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>public  HTTPConnection(const char * hostName, const Properties * mimeTypes, const char * documentRoot, const char * userDir)</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>Utwórz obiekt. Zapamiętaj tych parę rzeczy, które Ci się niedługo przydadzą.
</dl>
</dir><a name=finalize#HTTPConnection><ul><li><b>finalize</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private void finalize()</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>'Zfinalizuj się', tzn. odnotuj fakt, że ConnectionsManager zauważył, iż połączenie zostało zakończone i usunął ten obiekt ze swojej tablicy. Będzie więc można po re-inicjalizacji podać mu go znowu.
</dl>
</dir><a name=isFinalized#HTTPConnection><ul><li><b>isFinalized</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private bool isFinalized()</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>Odpowiada na pytanie, czy obiekt jest już 'zfianlizowany'.
</dl>
</dir><a name=isReadNeeded#HTTPConnection><ul><li><b>isReadNeeded</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private bool isReadNeeded()</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>metody, które muszą być 'przykryte' dla ConnectionsManager'a:
</dl>
</dir><a name=isWriteNeeded#HTTPConnection><ul><li><b>isWriteNeeded</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private bool isWriteNeeded()</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>Odpowiedz na pytanie, czy ten obiekt jest w tym momencie zaineresowany zapisem.
</dl>
</dir><a name=onReadable#HTTPConnection><ul><li><b>onReadable</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private void onReadable()</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>Metoda wywoływana, gdy odczyt jest możliwy
</dl>
</dir><a name=onWriteable#HTTPConnection><ul><li><b>onWriteable</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private void onWriteable()</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>Metoda wywoływana, gdy zapis jest możliwy
</dl>
</dir><a name=operator=#int#HTTPConnection><ul><li><b>operator=</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>public HTTPConnection & operator=(int sockfd)</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>inicjuj nowe połączenie (na podanym deskryptorze)
</dl>
</dir><a name=operatorint#HTTPConnection><ul><li><b>operatorint</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>private  operatorint()</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>Zwróć deskryptor naszego połączenia - czyli socket'u.
</dl>
</dir><a name=setPeer#struct_sockaddr_in_*#HTTPConnection><ul><li><b>setPeer</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>public void setPeer(struct sockaddr_in * p)</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>Ustaw sobie adres IP 'drugiej strony' celem zapisania tej informacji w logu.
</dl>
</dir><a name=~HTTPConnection#HTTPConnection><ul><li><b>~HTTPConnection</b></li></ul>
</a><dir><font face="Courier New,Courier"><font size=-1>public  ~HTTPConnection()</font></font><p>  </p>
<dl>
<dt><b>Documentation </b>desktruktor
</dl>
</dir><center><h3><a href=_index.html#_index>Return to top</a></h3></center></html>
