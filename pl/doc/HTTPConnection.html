<html><head><TITLE>HTTPConnection</TITLE></head>
<BODY BACKGROUND="../ltbrush.gif">
In file src/HTTPConnection.h:<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  HTTPConnection : public <!2><A HREF="AsyncConnection.html#DOC.1.3">AsyncConnection</A> </H2><BLOCKQUOTE>

Klasa implementująca interfejs AsyncConnection i realizująca połączenie z
klientem (cześcią obiektu HTTPConnection jest obiekt AsyncSocket)
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CAsyncConnection,MAsyncConnection.html,CHTTPConnection,MHTTPConnection.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.13.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>HTTPConnection</B>(const char *hostName, const <!1><A HREF="Properties.html">Properties</A> *mimeTypes, const char *documentRoot, const char *userDir) </B>
 <DD><I>Utwórz obiekt</I>
<DT><A HREF="#DOC.13.3"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <B>~HTTPConnection</B>() </B>
 <DD><I>desktruktor </I>
<DT><A HREF="#DOC.13.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="HTTPConnection.html#DOC.13.1">HTTPConnection</A>&amp;  <B>operator=</B>(int sockfd) </B>
 <DD><I>inicjuj nowe połączenie (na podanym deskryptorze) </I>
<DT><A HREF="#DOC.13.5"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setPeer</B>(struct sockaddr_in *p) </B>
 <DD><I>Ustaw sobie adres IP 'drugiej strony' celem zapisania tej informacji w logu</I>
</DL><DL>
<DT><h3>Private Fields</h3><DD><DT><A HREF="#DOC.13.6"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="AsyncSocket.html">AsyncSocket</A>  <B>sock</B> </B>
 <DD><I>socket - połączenie ze światem </I>
<DT><A HREF="#DOC.13.7"> <IMG BORDER=0 SRC=icon1.gif></A>  struct  sockaddr_in <B>peer</B> </B>
 <DD><I>tu zapamiętujemy adres klienta - w celu zapisu w logu </I>
<DT><A HREF="#DOC.13.8"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="HTTPRequest.html">HTTPRequest</A>  <B>request</B> </B>
 <DD><I>ten obiekt parsuje zapytanie przeglądarki i czyni odpowiedź </I>
<DT><A HREF="#DOC.13.9"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  size_t  <B>bufferSize</B> </B>
 <DD><I>32k - powinno wystarczyć </I>
<DT><A HREF="#DOC.13.10"> <IMG BORDER=0 SRC=icon1.gif></A> char  <B>buffer</B>[<!2><A HREF="HTTPConnection.html#DOC.13.9">bufferSize</A>] </B>
 <DD><I>bufor do odbierania i wysyłania danych </I>
<DT><A HREF="#DOC.13.11"> <IMG BORDER=0 SRC=icon1.gif></A> size_t  <B>nread</B> </B>
 <DD><I>ile już odebraliśmy/wysłaliśmy </I>
<DT><A HREF="#DOC.13.12"> <IMG BORDER=0 SRC=icon1.gif></A> size_t  <B>responseLength</B> </B>
 <DD><I>ile trzeba będzie wysłać bajtów nagłówka </I>
<DT><A HREF="#DOC.13.13"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>requestReceived</B> </B>
 <DD><I>czy odebraliśmy już kompletny request? </I>
<DT><A HREF="#DOC.13.14"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>finalized</B> </B>
 <DD><I>czy manager wie, że połączenie zakończone? </I>
<DT><A HREF="#DOC.13.15"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="File.html">File</A>*  <B>file</B> </B>
 <DD><I>Wskaźnik do pliku, który od czasu do czasu zdarzy się nam wysłać</I>
</DL><DL>
<DT><h3>Private Methods</h3><DD><DT><A HREF="#DOC.13.16"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>isReadNeeded</B>() const  </B>
 <DD><I>metody, które muszą być 'przykryte' dla ConnectionsManager'a: </I>
<DT><A HREF="#DOC.13.17"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>isWriteNeeded</B>() const  </B>
 <DD><I>Odpowiedz na pytanie, czy ten obiekt jest w tym momencie zaineresowany zapisem</I>
<DT><A HREF="#DOC.13.18"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>onReadable</B>() </B>
 <DD><I>Metoda wywoływana, gdy odczyt jest możliwy </I>
<DT><A HREF="#DOC.13.19"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>onWriteable</B>() </B>
 <DD><I>Metoda wywoływana, gdy zapis jest możliwy </I>
<DT><A HREF="#DOC.13.20"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>operator int</B>() const  </B>
 <DD><I>Zwróć deskryptor naszego połączenia - czyli socket'u</I>
<DT><A HREF="#DOC.13.2"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>finalize</B>() </B>
 <DD><I>'Zfinalizuj się', tzn</I>
<DT><A HREF="#DOC.13.21"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>isFinalized</B>() const  </B>
 <DD><I>Odpowiada na pytanie, czy obiekt jest już 'zfianlizowany'</I>
</DL></DL>
<hr><H3>Inherited from <A HREF="AsyncConnection.html">AsyncConnection:</A></h3>

<DL>
</DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

Klasa implementująca interfejs AsyncConnection i realizująca połączenie z
klientem (cześcią obiektu HTTPConnection jest obiekt AsyncSocket).
Zajmuje się tylko odbieraniem (i zapamiętywaniem) danych przesłanych od
klienta, oraz wysyłaniem odpowiedzi wygenerowanej przez obiekt
HTTPRequest. Obiekt tej klasy potrafi też wysłać plik wskazany przez
HTTPRequest'a.

</BLOCKQUOTE>
<DL>

<A NAME="HTTPConnection">
<A NAME ="DOC.13.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  HTTPConnection(const char *hostName, const <!1><A HREF="Properties.html">Properties</A> *mimeTypes, const char *documentRoot, const char *userDir)</B></TT>
<DD>Utwórz obiekt. Zapamiętaj tych parę rzeczy, które Ci się niedługo przydadzą. 
<DL></DL><P>
<A NAME="~HTTPConnection">
<A NAME ="DOC.13.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  ~HTTPConnection()</B></TT>
<DD>desktruktor 
<DL></DL><P>
<A NAME="operator=">
<A NAME ="DOC.13.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="HTTPConnection.html#DOC.13.1">HTTPConnection</A>&amp;  operator=(int sockfd)</B></TT>
<DD>inicjuj nowe połączenie (na podanym deskryptorze) 
<DL></DL><P>
<A NAME="setPeer">
<A NAME ="DOC.13.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setPeer(struct sockaddr_in *p)</B></TT>
<DD>Ustaw sobie adres IP 'drugiej strony' celem zapisania tej informacji w logu
<DL></DL><P>
<A NAME="sock">
<A NAME ="DOC.13.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="AsyncSocket.html">AsyncSocket</A>  sock</B></TT>
<DD>socket - połączenie ze światem 
<DL></DL><P>
<A NAME="peer">
<A NAME ="DOC.13.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  struct  sockaddr_in peer</B></TT>
<DD>tu zapamiętujemy adres klienta - w celu zapisu w logu 
<DL></DL><P>
<A NAME="request">
<A NAME ="DOC.13.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="HTTPRequest.html">HTTPRequest</A>  request</B></TT>
<DD>ten obiekt parsuje zapytanie przeglądarki i czyni odpowiedź 
<DL></DL><P>
<A NAME="bufferSize">
<A NAME ="DOC.13.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  size_t  bufferSize</B></TT>
<DD>32k - powinno wystarczyć 
<DL></DL><P>
<A NAME="buffer">
<A NAME ="DOC.13.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> char  buffer[<!2><A HREF="HTTPConnection.html#DOC.13.9">bufferSize</A>]</B></TT>
<DD>bufor do odbierania i wysyłania danych 
<DL></DL><P>
<A NAME="nread">
<A NAME ="DOC.13.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> size_t  nread</B></TT>
<DD>ile już odebraliśmy/wysłaliśmy 
<DL></DL><P>
<A NAME="responseLength">
<A NAME ="DOC.13.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> size_t  responseLength</B></TT>
<DD>ile trzeba będzie wysłać bajtów nagłówka 
<DL></DL><P>
<A NAME="requestReceived">
<A NAME ="DOC.13.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  requestReceived</B></TT>
<DD>czy odebraliśmy już kompletny request? 
<DL></DL><P>
<A NAME="finalized">
<A NAME ="DOC.13.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  finalized</B></TT>
<DD>czy manager wie, że połączenie zakończone? 
<DL></DL><P>
<A NAME="file">
<A NAME ="DOC.13.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="File.html">File</A>*  file</B></TT>
<DD>Wskaźnik do pliku, który od czasu do czasu zdarzy się nam wysłać
<DL></DL><P>
<A NAME="isReadNeeded">
<A NAME ="DOC.13.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  isReadNeeded() const </B></TT>
<DD>metody, które muszą być 'przykryte' dla ConnectionsManager'a: 
<DL></DL><P>
<A NAME="isWriteNeeded">
<A NAME ="DOC.13.17">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  isWriteNeeded() const </B></TT>
<DD>Odpowiedz na pytanie, czy ten obiekt jest w tym momencie zaineresowany zapisem
<DL></DL><P>
<A NAME="onReadable">
<A NAME ="DOC.13.18">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  onReadable()</B></TT>
<DD>Metoda wywoływana, gdy odczyt jest możliwy 
<DL></DL><P>
<A NAME="onWriteable">
<A NAME ="DOC.13.19">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  onWriteable()</B></TT>
<DD>Metoda wywoływana, gdy zapis jest możliwy 
<DL></DL><P>
<A NAME="operator int">
<A NAME ="DOC.13.20">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  operator int() const </B></TT>
<DD>Zwróć deskryptor naszego połączenia - czyli socket'u
<DL></DL><P>
<A NAME="finalize">
<A NAME ="DOC.13.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  finalize()</B></TT>
<DD>'Zfinalizuj się', tzn. odnotuj fakt, że ConnectionsManager zauważył, iż połączenie zostało zakończone i usunął ten obiekt ze swojej tablicy. Będzie więc można po re-inicjalizacji podać mu go znowu. 
<DL></DL><P>
<A NAME="isFinalized">
<A NAME ="DOC.13.21">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  isFinalized() const </B></TT>
<DD>Odpowiada na pytanie, czy obiekt jest już 'zfianlizowany'
<DL></DL><P></DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<STRONG>
Kod źródłowy tego programu oraz jego dokumentacja są chronione przez
Ustawę o prawie autorskim i prawach pokrewnych. Nie mogą być użyte
ani opublikowane w żadnych innych pracach bez pisemnej zgody ich
autorów.
<P>
This documentation and all of the sources are copyright protected and
may not be used or published in other works without express written
permission from the authors.
</P>
</STRONG>
Copyright &copy; 1999 Łukasz Hołody, Michał Jacykiewicz, Marcin Jarząb, Marek Konieczny. All rights reserved.

<HR>

<P ALIGN="CENTER">
<SMALL>
<A HREF="../">Strona główna projektu</A> |
<A HREF="../projektowa.html">Dokumentacja projektowa</A> |
<A HREF="../koncowa.html">Dokumentacja końcowa</A>
</SMALL>
</P>

<P Align=right><I>generated by <A HREF="http://www.zib.de/Visual/software/doc++/index.html">doc++</A></I>
</BODY>
