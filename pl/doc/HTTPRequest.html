<html><head><TITLE>HTTPRequest</TITLE></head>
<BODY BACKGROUND="../../../../gfx/backs/ltbrush.gif">
In file src/HTTPRequest.h:<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  HTTPRequest  </H2><BLOCKQUOTE>

Obiekt tej klasy zajmuje się parsowaniem zapytania klienta, zrozumieniem
go oraz wygenerowaniem właściwej odpowiedzi (zgodnie z protokołem HTTP)
</BLOCKQUOTE>
<hr>

<DL>
<DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.14.8"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>HTTPRequest</B>(const char *<!2><A HREF="HTTPRequest.html#DOC.14.9">hostName</A>, const <!1><A HREF="Properties.html">Properties</A> *<!2><A HREF="HTTPRequest.html#DOC.14.10">mimeTypes</A>, const char *<!2><A HREF="HTTPRequest.html#DOC.14.11">documentRoot</A>, const char *<!2><A HREF="HTTPRequest.html#DOC.14.6">userDir</A>) </B>
 <DD><I>
Standardowy konstruktor, w którym podajemy wskaźniki do później
wykorzystywanych obiektów</I>
<DT><A HREF="#DOC.14.1"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>isComplete</B>(const char *request) </B>
 <DD><I>
Metoda prawdza to co nam przysłała przeglądarka (a ja to podaję w
buforze tekstowym jako string - czyli zakończony znakiem '\0')</I>
<DT><A HREF="#DOC.14.2"> <IMG BORDER=0 SRC=icon1.gif></A> uint  <B>getResponse</B>(char *buffer, uint bufferLength) </B>
 <DD><I>
Metoda ta na podstawie zapytania przeglądarki (podawanego w metodzie
wyżej, ale podana także tutaj jeszcze raz, tylko tym razem możną ją
zniszczyć - a nawet trzeba</I>
<DT><A HREF="#DOC.14.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="File.html">File</A>*  <B>getFile</B>() </B>
 <DD><I>
Metoda ta zwraca wskaźnik do obiektu File, którego zawartość należy
wysłać, zaraz za nagłówkiem</I>
<DT><A HREF="#DOC.14.4"> <IMG BORDER=0 SRC=icon1.gif></A> const  char*  <B>getMethod</B>() const  </B>
 <DD><I>Zwraca metodę bieżącego zapytania</I>
<DT><A HREF="#DOC.14.5"> <IMG BORDER=0 SRC=icon1.gif></A> const  char*  <B>getURI</B>() const  </B>
 <DD><I>Zwraca URI bieżącego zapytania</I>
</DL><DL>
<DT><h3>Private Fields</h3><DD><DT><A HREF="#DOC.14.9"> <IMG BORDER=0 SRC=icon1.gif></A> const  char*  const  <B>hostName</B> </B>
 <DD><I>Nazwa komputera na którym jesteśmy uruchomieni - potrzebna w polu Location odpowiedzi HTTP</I>
<DT><A HREF="#DOC.14.10"> <IMG BORDER=0 SRC=icon1.gif></A> const  <!1><A HREF="Properties.html">Properties</A>*  const  <B>mimeTypes</B> </B>
 <DD><I>Obiekt 'rozpoznający' typy plików po rozszerzeniach ich nazwy</I>
<DT><A HREF="#DOC.14.11"> <IMG BORDER=0 SRC=icon1.gif></A> const  char*  const  <B>documentRoot</B> </B>
 <DD><I>Gdzie skłaowane są dokumenty z głównego drzewa</I>
<DT><A HREF="#DOC.14.6"> <IMG BORDER=0 SRC=icon1.gif></A> const  char*  const  <B>userDir</B> </B>
 <DD><I>W którym katalogu w katalgoach użytkowników szukać index</I>
<DT><A HREF="#DOC.14.12"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>haveContent</B> </B>
 <DD><I>wysyłamy coś oprócz nagłówka? / wysyłamy plik? </I>
<DT><A HREF="#DOC.14.13"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="FileInfo.html">FileInfo</A>  <B>fileinfo</B> </B>
 <DD><I>tu pamiętamy dane o pliku, którym interesuje się klient </I>
<DT><A HREF="#DOC.14.14"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="File.html">File</A>  <B>file</B> </B>
 <DD><I>a tu jest ewentualnie ten plik</I>
</DL><DL>
<DT><h3>Private Methods</h3><DD><DT><A HREF="#DOC.14.15"> <IMG BORDER=0 SRC=icon1.gif></A> const  char*  <B>resolvePathName</B>(char *) </B>
 <DD><I>metoda przerabia URI na pełną scieżkę dostępu do pliku </I>
<DT><A HREF="#DOC.14.16"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>generateResponseHeader</B>(char *buffer, uint bufferLength, const <!2><A HREF="HTTPRequest.html#DOC.14.7">ResponseHeader</A> &amp;hdr, const char *location, ulong contentLength, const char *contentType, time_t mtime) const  </B>
 <DD><I>Metoda generuje nagłówke odpowiedzi korzystając z podanych obiektów</I>
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

Obiekt tej klasy zajmuje się parsowaniem zapytania klienta, zrozumieniem
go oraz wygenerowaniem właściwej odpowiedzi (zgodnie z protokołem HTTP). 
Wskazuje też oraz otwiera plik, którego wysłaniem zająć się ma obiekt
HTTPConnection.

</BLOCKQUOTE>
<DL>

<A NAME="HTTPRequest">
<A NAME ="DOC.14.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  HTTPRequest(const char *<!2><A HREF="HTTPRequest.html#DOC.14.9">hostName</A>, const <!1><A HREF="Properties.html">Properties</A> *<!2><A HREF="HTTPRequest.html#DOC.14.10">mimeTypes</A>, const char *<!2><A HREF="HTTPRequest.html#DOC.14.11">documentRoot</A>, const char *<!2><A HREF="HTTPRequest.html#DOC.14.6">userDir</A>)</B></TT>
<DD>
Standardowy konstruktor, w którym podajemy wskaźniki do później
wykorzystywanych obiektów
<DL></DL><P>
<A NAME="isComplete">
<A NAME ="DOC.14.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  isComplete(const char *request)</B></TT>
<DD>
Metoda prawdza to co nam przysłała przeglądarka (a ja to podaję w
buforze tekstowym jako string - czyli zakończony znakiem '\0'). 
Zwraca true, jeśli request jest już odebrany w całości (zwykle
oznacza to, że kończy się dwoma znakami końca linii '\n' - ale nie
jest to regułą, choć tak powinno być). Lub zwraca false, jeśli
request nie jest jeszcze kompletny i należy spodziewać się, że coś z
sieci zaraz dojdzie. Wtedy metoda ta zostanie wywołana ponownie z
uzupełnionym buforem.
<DL></DL><P>
<A NAME="getResponse">
<A NAME ="DOC.14.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> uint  getResponse(char *buffer, uint bufferLength)</B></TT>
<DD>
Metoda ta na podstawie zapytania przeglądarki (podawanego w metodzie
wyżej, ale podana także tutaj jeszcze raz, tylko tym razem możną ją
zniszczyć - a nawet trzeba. Bufor przenaczony jest przecież teraz na
odpowiedź) formułuje nagłówek odpowiedzi. Mogą to już być np. jakieś
informacje o pliku, który zażyczyła sobie przeglądarka w zapytaniu. 
Odpowiedź tę umieszcza we wskazanym buforze tekstowym, którego
wielkość podana jest jako drugi argument.  Naturalnie odpowiedź nie
może przekroczyć tego rozmiaru, gdyż spowoduje to "SEGMENTATION
FAULT" i zakończenie bieżącego procesu. Należy się jednak spodziewać,
że dany bufor będzie miał conajmniej 32 kilobajty, a więc
wystarczająco dużo.  Metoda ta zwraca długość w bajtach nagłówka
odpowiedzi, który należy wysłać.
<DL></DL><P>
<A NAME="getFile">
<A NAME ="DOC.14.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="File.html">File</A>*  getFile()</B></TT>
<DD>
Metoda ta zwraca wskaźnik do obiektu File, którego zawartość należy
wysłać, zaraz za nagłówkiem.  Zwraca NULL jeśli nie należy nic więcej
(poza nagłówkiem) wysyłać.  Jeśli skończę z plikiem, to sam go zamknę
- Ty więc o jego zamykanie nie musisz martwić.
<DL></DL><P>
<A NAME="getMethod">
<A NAME ="DOC.14.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> const  char*  getMethod() const </B></TT>
<DD>Zwraca metodę bieżącego zapytania. Metoda na potrzeby wpisu w pliku acces.log 
<DL></DL><P>
<A NAME="getURI">
<A NAME ="DOC.14.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> const  char*  getURI() const </B></TT>
<DD>Zwraca URI bieżącego zapytania. Metoda na potrzeby wpisu w pliku acces.log 
<DL></DL><P>
<A NAME="hostName">
<A NAME ="DOC.14.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> const  char*  const  hostName</B></TT>
<DD>Nazwa komputera na którym jesteśmy uruchomieni - potrzebna w polu Location odpowiedzi HTTP
<DL></DL><P>
<A NAME="mimeTypes">
<A NAME ="DOC.14.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> const  <!1><A HREF="Properties.html">Properties</A>*  const  mimeTypes</B></TT>
<DD>Obiekt 'rozpoznający' typy plików po rozszerzeniach ich nazwy
<DL></DL><P>
<A NAME="documentRoot">
<A NAME ="DOC.14.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> const  char*  const  documentRoot</B></TT>
<DD>Gdzie skłaowane są dokumenty z głównego drzewa
<DL></DL><P>
<A NAME="userDir">
<A NAME ="DOC.14.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> const  char*  const  userDir</B></TT>
<DD>W którym katalogu w katalgoach użytkowników szukać index.html i innych dokumentów. 
<DL></DL><P>
<A NAME="haveContent">
<A NAME ="DOC.14.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  haveContent</B></TT>
<DD>wysyłamy coś oprócz nagłówka? / wysyłamy plik? 
<DL></DL><P>
<A NAME="fileinfo">
<A NAME ="DOC.14.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="FileInfo.html">FileInfo</A>  fileinfo</B></TT>
<DD>tu pamiętamy dane o pliku, którym interesuje się klient 
<DL></DL><P>
<A NAME="file">
<A NAME ="DOC.14.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="File.html">File</A>  file</B></TT>
<DD>a tu jest ewentualnie ten plik
<DL></DL><P>
<A NAME="resolvePathName">
<A NAME ="DOC.14.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> const  char*  resolvePathName(char *)</B></TT>
<DD>metoda przerabia URI na pełną scieżkę dostępu do pliku 
<DL></DL><P>
<A NAME="ResponseHeader">
<A NAME ="DOC.14.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  class  ResponseHeader</B></TT>
<DD>
Prywatna klasa klasy HTTPRequest. Jej obiekty są nagłówkami
odpowiedzi wysyłanymi do klientów. Atrybutami tych oiektów są: kod
odpowiedzi, jej krótki opis, opis w HTMLu
<DL></DL><P>
<A NAME="generateResponseHeader">
<A NAME ="DOC.14.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  generateResponseHeader(char *buffer, uint bufferLength, const <!2><A HREF="HTTPRequest.html#DOC.14.7">ResponseHeader</A> &amp;hdr, const char *location, ulong contentLength, const char *contentType, time_t mtime) const </B></TT>
<DD>Metoda generuje nagłówke odpowiedzi korzystając z podanych obiektów
<DL></DL><P></DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<STRONG>
Kod źródłowy tego programu oraz jego dokumentacja są chronione przez
Ustawę o prawie autorskim i prawach pokrewnych. Nie mogą być użyte
ani opublikowane w żadnych innych pracach bez pisemnej zgody ich
autorów.
<P>
This documentation and all of the sources are copyright protected and
may not be used or published in other works without express written
permission from the authors.
</P>
</STRONG>
Copyright &copy; 1999 Łukasz Hołody, Michał Jacykiewicz, Marcin Jarząb, Marek Konieczny. All rights reserved.

<HR>

<P ALIGN="CENTER">
<SMALL>
<A HREF="../">Strona główna projektu</A> |
<A HREF="../projektowa.html">Dokumentacja projektowa</A> |
<A HREF="../koncowa.html">Dokumentacja końcowa</A>
</SMALL>
</P>

<P Align=right><I>generated by <A HREF="http://www.zib.de/Visual/software/doc++/index.html">doc++</A></I>
</BODY>
