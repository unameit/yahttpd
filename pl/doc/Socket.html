<html><head><TITLE>Socket</TITLE></head>
<BODY BACKGROUND="../../../../gfx/backs/ltbrush.gif">
In file src/Socket.h:<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  Socket : public <!2><A HREF="Descriptor.html#DOC.8.4">Descriptor</A> </H2><BLOCKQUOTE>

Obiekty tej klasy to standardowe gniazda (socket'y) systemu UNIX(R)
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=95>
<param name=classes value="CDescriptor,MDescriptor.html,CSocket,MSocket.html,CAsyncSocket,MAsyncSocket.html">
<param name=before value="M,M,M^_">
<param name=after value="Md_,M,M">
<param name=indent value="0,1,1">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.19.3"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Socket</B>() </B>
 <DD><I>Otwórz obiekt Socket, ale go ie otwieraj </I>
<DT><A HREF="#DOC.19.4"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Socket</B>(int i) </B>
 <DD><I>Utwórz obiekt Socket, z deskryptora, który Ci dajê</I>
<DT><A HREF="#DOC.19.5"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Socket</B>(int domain, int type, int protocol = 0) </B>
 <DD><I>Utwórz Socket ze wskazanej rodziny i podanego typu </I>
<DT><A HREF="#DOC.19.6"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>connect</B>(const char *hostName, ushort port) </B>
 <DD><I>Po³±cz to gniazdo z podanym komputerem, na podanym porcie</I>
<DT><A HREF="#DOC.19.7"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>connect</B>(const struct sockaddr_in *addr) </B>
 <DD><I>Po³±cz to gniazdo z komputerem, którego adres podany jest w tej strukturze</I>
<DT><A HREF="#DOC.19.8"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>bind</B>(const char *hostName, ushort port) </B>
 <DD><I>Zrób bind tego Socket'a, czyli przypisz go do interfejsu sieciowego wskazywanego podan± nazw± komputera oraz do portu o podanym numerze</I>
<DT><A HREF="#DOC.19.9"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>bind</B>(const struct sockaddr_in *addr) </B>
 <DD><I>Przypisz to gniazdo do adresu podanego w tej strukturze danych przekazanej jako argument</I>
<DT><A HREF="#DOC.19.1"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>accept</B>() </B>
 <DD><I>Akceptuj po³±czenie ze ¶wiata</I>
<DT><A HREF="#DOC.19.2"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>accept</B>(struct sockaddr_in *) </B>
 <DD><I>Akceptuj po³±czenie ze ¶wiata</I>
<DT><A HREF="#DOC.19.10"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>listen</B>(int backlog) </B>
 <DD><I>Pozwól na backlog oczekuj±cych po³±czeñ w kolejce na zaakceptowanie przez nas</I>
<DT><A HREF="#DOC.19.11"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="Socket.html#DOC.19.3">Socket</A>&amp;  <B>operator=</B>(int) </B>
 <DD><I>Podany deskryptor niech bêdzie nowym moim</I>
</DL><DL>
<DT><h3>Private Methods</h3><DD><DT><A HREF="#DOC.19.12"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>convert</B>(struct sockaddr_in *addr, const char *hostName, ushort port) const  </B>
 <DD><I>Zapytaj DNSa o IP tego komputera i wpisz mi to do struktury sockaddr_in</I>
</DL></DL>
<hr><H3>Inherited from <A HREF="Descriptor.html">Descriptor:</A></h3>

<DL>
<DL>
<DT><h3>Public Methods</h3><DD><DT><IMG SRC=icon2.gif> void  <B>close</B>()
<DT><IMG SRC=icon2.gif> int  <B>read</B>()
<DT><IMG SRC=icon2.gif> size_t  <B>read</B>(void *buffer, size_t nbytes, bool full = true)
<DT><IMG SRC=icon2.gif> size_t  <B>readv</B>(const struct iovec *iov, size_t count, bool full = true)
<DT><IMG SRC=icon2.gif> void  <B>write</B>(u_char)
<DT><IMG SRC=icon2.gif> size_t  <B>write</B>(const void *buffer, size_t, bool full = true)
<DT><IMG SRC=icon2.gif> size_t  <B>writev</B>(const struct iovec *iov, size_t count, bool full = true)
<DT><IMG SRC=icon2.gif> inline  <B>operator int</B>() const 
</DL><DL>
<DT><h3>Protected Fields</h3><DD><DT><IMG SRC=icon2.gif> int  <B>fd</B>
</DL><DL>
<DT><h3>Protected Methods</h3><DD><DT><IMG SRC=icon2.gif> void  <B>makeAsync</B>()
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

Obiekty tej klasy to standardowe gniazda (socket'y) systemu UNIX(R).
Klasa rozszerza mo¿liwo¶ci klasy Descriptor o metody specyficzne dla
deskryptorów gniazd (takie jak: connect, bind, listen, accept).

</BLOCKQUOTE>
<DL>

<A NAME="Socket">
<A NAME ="DOC.19.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Socket()</B></TT>
<DD>Otwórz obiekt Socket, ale go ie otwieraj 
<DL></DL><P>
<A NAME="Socket">
<A NAME ="DOC.19.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Socket(int i)</B></TT>
<DD>Utwórz obiekt Socket, z deskryptora, który Ci dajê
<DL></DL><P>
<A NAME="Socket">
<A NAME ="DOC.19.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Socket(int domain, int type, int protocol = 0)</B></TT>
<DD>Utwórz Socket ze wskazanej rodziny i podanego typu 
<DL></DL><P>
<A NAME="connect">
<A NAME ="DOC.19.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  connect(const char *hostName, ushort port)</B></TT>
<DD>Po³±cz to gniazdo z podanym komputerem, na podanym porcie
<DL></DL><P>
<A NAME="connect">
<A NAME ="DOC.19.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  connect(const struct sockaddr_in *addr)</B></TT>
<DD>Po³±cz to gniazdo z komputerem, którego adres podany jest w tej strukturze
<DL></DL><P>
<A NAME="bind">
<A NAME ="DOC.19.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  bind(const char *hostName, ushort port)</B></TT>
<DD>Zrób bind tego Socket'a, czyli przypisz go do interfejsu sieciowego wskazywanego podan± nazw± komputera oraz do portu o podanym numerze
<DL></DL><P>
<A NAME="bind">
<A NAME ="DOC.19.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  bind(const struct sockaddr_in *addr)</B></TT>
<DD>Przypisz to gniazdo do adresu podanego w tej strukturze danych przekazanej jako argument
<DL></DL><P>
<A NAME="accept">
<A NAME ="DOC.19.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  accept()</B></TT>
<DD>Akceptuj po³±czenie ze ¶wiata. Zwróæ mi deskryptor nowo utworzonego w tym celu gniazda. 
<DL></DL><P>
<A NAME="accept">
<A NAME ="DOC.19.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  accept(struct sockaddr_in *)</B></TT>
<DD>Akceptuj po³±czenie ze ¶wiata. Adres maszyny, sk±d pochodzi po³±czenie zapisz do struktury przekazywanej jako parametr. 
<DL></DL><P>
<A NAME="listen">
<A NAME ="DOC.19.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  listen(int backlog)</B></TT>
<DD>Pozwól na backlog oczekuj±cych po³±czeñ w kolejce na zaakceptowanie przez nas
<DL></DL><P>
<A NAME="operator=">
<A NAME ="DOC.19.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="Socket.html#DOC.19.3">Socket</A>&amp;  operator=(int)</B></TT>
<DD>Podany deskryptor niech bêdzie nowym moim
<DL></DL><P>
<A NAME="convert">
<A NAME ="DOC.19.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  convert(struct sockaddr_in *addr, const char *hostName, ushort port) const </B></TT>
<DD>Zapytaj DNSa o IP tego komputera i wpisz mi to do struktury sockaddr_in
<DL></DL><P></DL>
<hr>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="AsyncSocket.html"> AsyncSocket </A><br>
</DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<STRONG>
Kod ¼ród³owy tego programu oraz jego dokumentacja s± chronione przez
Ustawê o prawie autorskim i prawach pokrewnych. Nie mog± byæ u¿yte
ani opublikowane w ¿adnych innych pracach bez pisemnej zgody ich
autorów.
<P>
This documentation and all of the sources are copyright protected and
may not be used or published in other works without express written
permission from the authors.
</P>
</STRONG>
Copyright &copy; 1999 £ukasz Ho³ody, Micha³ Jacykiewicz, Marcin Jarz±b, Marek Konieczny. All rights reserved.

<HR>

<P ALIGN="CENTER">
<SMALL>
<A HREF="../">Strona g³ówna projektu</A> |
<A HREF="../projektowa.html">Dokumentacja projektowa</A> |
<A HREF="../koncowa.html">Dokumentacja koñcowa</A>
</SMALL>
</P>

<P Align=right><I>generated by <A HREF="http://www.zib.de/Visual/software/doc++/index.html">doc++</A></I>
</BODY>
