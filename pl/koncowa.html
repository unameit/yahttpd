<HTML>

<HEAD>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
  <META NAME="author" CONTENT="Michal Jacykiewicz">
  <META NAME="generator" CONTENT="Yatz's mind powered by Linux 2.0.36 i586">
  <TITLE>Systemy operacyjne - demon HTTP - dokumentacja koncowa</TITLE>
</HEAD>

<BODY BACKGROUND="ltbrush.gif">

<H1 ALIGN="CENTER">Systemy operacyjne - projekt</H1>
<H3 ALIGN="CENTER">Micha³ Jacykiewicz</H3>

<B>
<BIG>
<OL TYPE="I">
<LI><A HREF="#temat">Temat zadania</A></LI>
<LI><A HREF="#zalozenia">Za³o¿enia ogólne</A></LI>
<LI><A HREF="#http">Opis protoko³u HTTP</A></LI>
  <SMALL>
  <OL>
    <LI><A HREF="#podstawy">Podstawy HTTP</A></LI>
    <LI><A HREF="#zapytanie">Zapytanie klienta</A></LI>
    <LI><A HREF="#kody">Kody odpowiedzi serwera</A></LI>
    <LI><A HREF="#naglowki">Nag³ówki HTTP</A></LI>
  </OL>
  </SMALL>
<LI><A HREF="#projekt">Projekt</A></LI>
<SMALL>
<OL>
  <LI><A HREF="#dyskusja">Dyskusja mo¿liwych wariantów realizacji projektu</A></LI>
  <LI><A HREF="#obiekty">Model obiektowy</A></LI>
  <LI><A HREF="#klasy">Opis zaprojektowanych klas</A></LI>
  <LI><A HREF="#dzialanie">Opis sposobu funkcjonowania oprogramowania</A></LI>
  <LI><A HREF="#zmiany">Zmiany w projekcie</A></LI>
</OL>
</SMALL>
<LI><A HREF="#implementacja">Implementacja</A></LI>
<SMALL>
<OL>
  <LI><A HREF="#kompatybilnosc">Kompatybilno¶æ</A></LI>
  <LI><A HREF="#kompilacja">Informacje o sposobie kompilacji</A></LI>
  <LI><A HREF="#podrecznik">Podrêcznik u¿ytkownika</A></LI>
</OL>
</SMALL>
<LI><A HREF="#podsumowanie">Podsumowanie</A></LI>
</OL>
</BIG>
</B>

<HR WIDTH="60%" SIZE="3">


<OL TYPE="I">

<A NAME="temat"></A>
<H3><LI>Temat zadania</LI></H3>
<P>
Serwer WWW (daemon HTTP).
</P>

<A NAME="zalozenia"></A>
<H3><LI>Za³o¿enia ogólne</LI></H3>

<UL TYPE="DISC">
  <LI>Demon HTTP pracuj±cy w ¶rodowisku UNIX</A><SMALL>&reg;</SMALL>.</LI>
  <LI>Komunikacja wg protoko³u HTTP w wersji 1.0.</LI>
  <LI>Implementacja w jêzyku C++ z wykorzystaniem funkcji standardu POSIX.</LI>
  <LI>Wykorzystanie wielow±tkowo¶ci oraz zaawansowanych sposobów komunikacji miêdzyprocesowej.</LI>
</UL>

<A NAME="http"></A>
<H3><LI>Opis protoko³u HTTP</LI></H3>

<OL>

<A NAME="podstawy"></A>
<H4><LI>Podstawy HTTP</LI></H4>

<P>
<B>The Hyper Transfer Protocol (HTTP)</B> jest jêzykiem jakiego klienci
sieci WWW i serwery pracuj±ce w tej sieci u¿ywaj± do porozumiewania siê.
Jest to w³a¶ciwie podstawa sieci WWW. Bazuje on na wzajemnej wymianie
nag³ówków ¿±dania i odpowiedzi (ang. <I>request and response headers</I>) w
wielu wierszach. Mamy tutaj do czynienia z klientem (przegl±dark±), który
inicjuje komunikacjê, poprzez wys³anie do serwera nag³ówka ¿±dania.
Nastêpnie serwer odpowiada na to ¿±danie wys³aniem nag³ówka odpowiedzi wraz
z do³±czonymi danymi, które s± ¿±danymi zasobami (strona WWW, plik
graficzny, audio itp.).
</P>

Wszystkie transakcje HTTP budowane s± na podstawie tego samego, zasadniczego
formatu. Ka¿de zapytanie i odpowied¼ klienta sk³ada siê z trzech czê¶ci:
linii zapytania lub odpowiedzi, sekcji nag³ówków i zasadniczej czê¶ci.

<P>Klient inicjuje transakcje w sposób nastêpuj±cy:</P>

<UL TYPE="DISC">
  <LI>Po³±czenie z serwerem na porcie o okre¶lonym numerze (domy¶lnie jest to 80). Nastêpnie jest zapytanie o dokument, zawierajace polecenie <I>method</I>, po którym umieszczony jest adres dokumentu i numer wersji HTTP (u¿ywanej przez klienta).</LI>
  <LI>Nastêpnie klient przesy³a opcjonalnie informacje zawarte w nag³ówku, informuj±c serwer o swojej konfiguracji oraz akceptowanych formatach dokumentów. Ka¿da informacja zawarta w nag³ówku umieszczana jest w osobnych liniach, zawieraj±cych nazwê nag³ówka i przekazywan± warto¶æ. Na zakoñczenie czê¶ci zawieraj±cej nag³ówek wysy³ana jest pusta linia.</LI>
  <LI>Nastêpnie klient mo¿e wys³aæ dodatkowe dane (np. dane do programów <CODE>CGI</CODE> obs³uguj±ce metodê <CODE>POST</CODE>).</LI>
</UL>

<P>Natomiast serwer odpowiada w sposób nastêpuj±cy:</P>

<UL TYPE="DISC">
  <LI>Serwer wysy³a odpowied¼ w postaci linii zawieraj±cej trzy pola: wersja HTTP, kod stanu i opis. Pole zawieraj±ce wersjê HTTP informuje o numerze wersji protoko³u jaka zosta³a u¿yta do udzielenia odpowiedzi. Pole zawieraj±ce kod stanu jest polem o o trzech cyfrach zawierajacy wynik dzia³ania na serwerze, wysy³anego przez klienta zapytania. Opis, który nastêpuje po kodzie stanu, jest zwyk³ym tekstem, który w postaci notatki opisuje znaczenie kodu stanu.</LI>
  <LI>Po linii stanu, serwer wysy³a do do klienta informacje nag³ówka zawieraj±ce dane dotyczace serwera i dokumentu ¿±danego przez klienta. Po nag³ówku zawsze natêpuje linia pusta, oznaczaj±ca jegokoniec.</LI>e
  <LI>Je¶li zapytanie klienta zosta³o odebane i przetworzone pomy¶lnie, przesy³ane s± ¿±dane przez niego dane (kopia pliku lub odpowied¼ wygenerowana przez program <CODE>CGI</CODE>). Je¶li zapytanie klienta nie mo¿e byæ spe³nione, wysy³ane s± informacje dlaczego serwer nie mo¿e odpowiedzieæ na zapytanie.</LI>
</UL>

<P>
W HTTP 1.0, po zakoñczeniu wysy³ania przez serwer odpowiedzi nastêpuje
zakoñczenie transakcji i roz³±czenie z klientem. Zabezpieczeniem przed
zrywaniem po³±czeñ jest wysy³anie nag³ówka <I>Connection: Keep Alive</I>. W
HTTP 1.1, transakcja mo¿e rwaæ dopóty, dopóki program klienta lub serwer
wyra¼nie nie zarz±daj± zakoñczenia po³±czenia. Bêd±c protoko³em bez kontroli
stanu, HTTP nie mo¿e przekazywaæ informacji z jednej transakcji do drugiej,
przez co ka¿da nastêpna transakcja musi rozpoczynaæ ca³± procedurê od
pocz±tku. Zalet± takiego rozwi±zania jest to, ¿e serwer HTTP mo¿e w tym
czasie obs³u¿yæ znacznie wiêksz± liczbê odwo³añ od klientów, w³a¶nie dziêki
temu, ¿e nie jest obci±¿ony dodatkowymi zadaniami ¶ledzenia parametrów sesji
i przekazywania ich z po³±czenia na po³±czenie. Wad± natomiast konieczno¶æ
wykorzystywania ukrytych pól tekstowych lub <I>cookies</I> dla
przechowywania informacji i przekazywania ich z jednej transakcji do
drugiej.

</P>

<A NAME="zapytanie"></A>
<H4><LI>Zapytanie klienta</LI></H4>

<P>
Zapytania klienta dzielone s± na trzy czê¶ci. Pierwsza linia wysy³anej do
serwera wiadomo¶ci zawsze zawiera polecenie HTTP o nazwie <I>method</I>,
nastêpnie umieszczany jest <CODE>URI</CODE> (<I>Uniform Resources Identifier</I>)
wskazuj±cy plik lub zasoby, o które klient pyta oraz numer wersji u¿ywanego
HTTP. Nastêpne linie zapytania zawieraj± informacje nag³ówkowe, gdzie
umieszczone s± dane zawieraj±ce informacje o rodzaju danych przesy³anych do
serwera. Trzecia czê¶æ zapytania klienta zawiera zasadnicz± informacjê,
któr± s± przesy³ane do serwera dane.
</P>

<P>
Metod± jest polecenie HTTP umieszczone na pocz±tku pierwszej linii zapytania
wysy³anego przez klienta. Metoda informuje serwer o celu wys³ania zapytania.
Istniej± trzy g³ówne metody, zdefiniowane dla protoko³u HTTP: <CODE>GET</CODE>, <CODE>HEAD</CODE>,
<CODE>POST</CODE>. Inne metody równie¿ maj± przyjêt± definicjê, ale nie s± obs³ógiwane
przez tak du¿± liczbê serwerów. Nazwy metod musz± byæ pisane du¿ymi
literami.
</P>

<UL TYPE="DISC">

<A NAME="GET"></A>
<B><LI>Metoda <CODE>GET</CODE></LI></B> jest zapytaniem o informacje
znajduj±ce siê pod okre¶lonym adresem <CODE>URI</CODE> na serwerze. Jest ona powszechnie
u¿ywana przez przegl±darki do ¶ci±gania i wy¶wietlania zawarto¶ci
dokumentów. Je¶li klient w wys³anym zapytaniu u¿ywa <CODE>GET</CODE>, serwer odpowiada mu
lini± stanu, nag³ówkami oraz przesy³a potrzebne dane. Je¶li z powodu b³êdów
serwer nie jest w stanie odpowiedzieæ na zapytanie, wysy³a do klienta
wyja¶nienie w postaci tekstu umieszczonego w czê¶ci odpowiedzi zawieraj±cej
dane. Czê¶æ zasadnicza zapytania <CODE>GET</CODE> jest zawsze pusta. Jest to wiêc rodzaj
rozkazu o okre¶lony plik. Nazwa tego pliku jest zwykle okre¶lona przez
podanie pe³nej ¶cie¿ki dostêpu na serwerze. Metoda <CODE>GET</CODE> jest równie¿
wykorzystywana do przesy³ania danych z formularzy do <CODE>CGI</CODE>. Przesy³ane dane
do³±czane s± do URL i znajduj± siê w tej samej linii zapytania co polecenie
<CODE>GET</CODE>. Je¶li okre¶lono metodê jako <CODE>GET</CODE>, to po znaku zapytania, umieszczonym po
URL, dopisywane s± wszystkie pary klucz=warto¶æ, zawieraj±ce dane z
wype³nionego formularza. Pary te rozdzielane s± ampersandem. Aby u¿ywaæ
specjalnych znaków w charakterze zwyk³ych, oprogramowanie klienta musi
stosowaæ notacjê szesnastkow±.

<A NAME="HEAD"></A>
<B><LI>Metoda <CODE>HEAD</CODE></LI></B> jest z punktu widzenia sposobu
dzia³ania podobna do <CODE>GET</CODE>, z t± ró¿nic±, ¿e serwer nie wysy³a
¿adnych informacji w czê¶ci odpowiedzi przeznaczonej na dane. Metoda
<CODE>HEAD</CODE> pozwala wiêc na pobranie z serwera informacji o pliku lub
zasobach serwera. Metoda ta jest u¿ywana wtedy, gdy klient chce znale¼æ
informacjê o dokumencie i jednocze¶nie nie chce tego dokumentu kopiowaæ z
serwera. Np. klient mo¿e otrymywaæ nastêpuj±ce informacje:
<UL>
  <LI>czas ostatniej modyfikacji dokumentu (przydatne przy keszowaniu)</LI>
  <LI>rozmiar dokumentu (dane przydatne przy okre¶laniu wyrównania strony, przewidywanego czasu przesy³ania pliku itp.)</LI>
  <LI>rodzaj dokumentu (przy przegl±daniu dokumetów tylko tego samego typu)</LI>
  <LI>rodzaj serwera (w³a¶ciwe przygotowanie zapytañ)</LI>
</UL>

<A NAME="POST"></A>

<B><LI>Metoda <CODE>POST</CODE></LI></B> pozwala na przesy³anie danych do
serwera w zapytaniu wysy³anym przez klienta. Dane te s± nastêpnie kierowane
do programu dokonuj±cego ich analizy (najczê¶ciej skrypt <CODE>CGI</CODE>).
mo¿na jej u¿yæ np do:
<UL>
  <LI>serwisów sieciowych, takich jak korespondencja do grup dyskusyjnych</LI>
  <LI>programów pracuj±cych z interfejsem linii poleceñ</LI>
  <LI>dokonania adnotacji w dokumentach na serwerze</LI>
  <LI>programów obs³uguj±cych bazy danych</LI>
</UL>
Dane, które wysy³ane s± do serwera, umieszczone s± w zasadniczej czê¶ci
przesy³anego zapytania. Po przetworzeniu przez serwer zapytania typu
<CODE>POST</CODE> i jego nag³ówków, pozosta³a czê¶æ wiadomo¶ci przekazywana
jest do programu, który wskazano w <CODE>URI</CODE>. Pozwala to na translacjê danych do
postaci listy zmiennych i wartosci przetwarzanych nastêpnie przez
<CODE>CGI</CODE>.
<BR><BR>
<A NAME="INNE"></A>
<B><LI>Inne metody</LI></B>
Poni¿sze metody s± zdefiniowane, choæ nie s± zbyt czêsto stosowane:
<UL>
  <LI><CODE><B>LINK</B></CODE> - wymaga aby informacja zawarta w nag³ówku by³a skojarzona z dokumentem znajduj±cym siê na serwerze</LI>
  <LI><CODE><B>UNLINK</B></CODE> - wymaga aby informacja zawarta w nag³ówku by³a oddzielona od dokumentu na serwerze</LI>
  <LI><CODE><B>PUT</B></CODE> - wymaga aby ca³a zasadnicza czê¶æ zapytania zosta³a zapisana w okre¶lonym <CODE>URI</CODE></LI>
  <LI><CODE><B>DELETE</B></CODE> - wymaga usuniêcia danych okre¶lonych przez <CODE>URI</CODE>, znajduj±cych siê w serwerze</LI>
  <LI><CODE><B>OPTIONS</B></CODE> - wymaga przes³ania informacji o opcjach komunikacyjnych dostêpnych na serwerze. Symbol gwiazdka ( * ) oznacza przes³anie wszystkich informacji dostêpnych na serwerze</LI>  
  <LI><CODE><B>TRACE</B></CODE> - wymaga aby ca³a zasadnicza czê¶æ wysy³anego zapytania zosta³a odes³ana w nienaruszonej postaci</LI> 
</UL>

</UL>

<A NAME="kody"></A>
<H4><LI>Kody odpowiedzi serwera</LI></H4>

Odpowied¼ serwera na zapytanie klienta podzielona jest na trzy czê¶ci.
Pierwsza linia to linia odpowiedzi wys³anej przez serwer, w której znajduje
siê numer wersji HTTP, numer okre¶laj±cy status zapytania oraz krótki tekst
opisuj±cy ten status. Po pierwszej linii odpowiedzi nastêpuj±: informacja o
nag³ówku oraz zasadnicza czê¶æ wiadomo¶ci.Pierwsza linia informuje czy
zapytanie klienta powiod³o siê czy te¿ nie oraz dlaczego tak siê sta³o.
Status podawany jest za pomoc± <I>kodu odpowiedzi</I> zapisanego trzema
cyframi, po którym nastêpuje informacja wyja¶niaj±ca. Kody statusu s± zwykle
generowane przez serwery WWW, mog± byæ tak¿e generowane przez skrypty
<CODE>CGI</CODE>, które pomijaj± nag³ówki serwera i dopisuja w³asne. Kody te
pogrupowane s± w nastêpuj±ce zestawy:

<BR><BR>
<CENTER>
<TABLE BORDER CELLSPACING="1" CELLPADDING="1">
<TR>
  <TD><B><CENTER>Zakres kodu</CENTER></B></TD>
  <TD><B><CENTER>Znaczenie odpowiedzi</CENTER></B></TD>
</TR><TR>
  <TD><CENTER>100 - 199</CENTER></TD>
  <TD>informacyjne</TD>
</TR><TR>
  <TD><CENTER>200 - 299</CENTER></TD>
  <TD>zapytanie klienta powiod³o siê</TD>
</TR><TR>
  <TD><CENTER>300 - 399</CENTER></TD>
  <TD>zapytanie klienta zosta³o przekazane, konieczne dalsze dzia³anie</TD>
</TR><TR>
  <TD><CENTER>400 - 499</CENTER></TD>
  <TD>zapytanie klienta nie powiod³o siê</TD>
</TR><TR>
  <TD><CENTER>500 - 599</CENTER></TD>
  <TD>b³±d serwera</TD>
</TR>
</TABLE>
</CENTER>

<P>
Protokó³ HTTP definiuje tylko kilka kodów w ka¿dym z podanych zakresów, inne
kody mog± byæ definiowane przez serwer. Jesli oprogramowanie otrzyma
odpowied¼ z kodem, którego nie potrafi rozpoznaæ, powinno przynajmniej
rozpoznaæ podstawowe jego znaczenie.
</P>

<A NAME="naglowki"></A>
<H4><LI>Nag³ówki HTTP</LI></H3>

Nag³ówki HTTP u¿ywane s± do przekazywania wszelkiego rodzaju informacji
pomiêdzy klientem a serwerem. S± cztery ró¿ne kategorie nag³ówków:

<OL TYPE="a">
  <LI><B>ogólne</B> - informacje nie zwi±zane z klientem, serwerem lub HTTP</LI>
  <LI><B>zapytanie</B> - preferowane formaty dokumentów i parametry serwera</LI>
  <LI><B>odpowied¼</B> - informacje na temat serwera wysy³aj±cego odpowied¼</LI>
  <LI><B>zawarto¶æ</B> - informacje o danych przesy³anych pomiedzy klientem i serwerem</LI>
</OL>

Nag³ówki z kategorii ogólne i zawarto¶æ s± takie same dla klienta i serwera.
Wszystkie nag³ówki znajduj±ce sie w wiadomo¶ci HTTP zawieraj± nazwê
nag³ówka, po której nastêpuje dwukopek (:), spacja i warto¶æ nag³ówka. W
nazwach nag³ówka nie jest rozró¿nialna wielko¶æ liter. Warto¶æ nag³ówka mo¿e
zajmowaæ kilka linii, pod warunkiem ¿e ka¿da nowa linia rozpoczyna siê
przynajmniej jedn± spacj± lub tabulatorem.

<BR>

W specyfikacji HTTP 1.1 mo¿emy wyró¿niæ:

<OL TYPE="a">
  <LI><B>nag³ówki ogólne</B> - nag³ówki te u¿ywane s± w zapytaniach klienta jak i w odpowiedziach serwera<BR></LI>
  <LI><B>nag³ówki zapytania klienta</B> - informuj± serwer o konfiguracji oprogramowania klienta i preferowanych formatach dokumentów. S± umieszczane w wiadomosciach wysy³anych przez klienta i zawieraj± informacje tylko o nim. </LI><BR>
  <LI><B>nag³ówki odpowiedzi serwera</B> - u¿ywane s± w przesy³anych przez serwer komunikatach i zawieraj± informacje o serwerze oraz sposobie w jaki obs³uguje on zapytanie. <BR></LI>
  <LI><B>nag³ówki zawarto¶ci</B> - u¿ywane s± zarówno w zapytaniach klienta jak i odpowiedziach serwera. Zawieraj± informacje o danych przesy³anych w wiadomo¶ciach HTTP.</LI>
</OL>

</OL>

<A NAME="projekt"></A>
<H3><LI>Projekt</LI></H3>
<OL>

<A NAME="dyskusja"></A>
<H4><LI>Dyskusja mo¿liwych wariantów realizacji projektu</LI></H4>

<P>
Projekt mo¿na by³o zrealizowaæ na conajmniej kilka sposobów.
Warianty te zosta³y omówionie w
<A HREF="projektowa.html#dyskusja">dokumentacji projektowej</A>.
<BR>

Wystarczy, ¿e wspomnimy tutaj, i¿ wybrali¶my wariant, który umo¿liwia
obs³ugiwanie najwiêkszej liczby (w porównaniu do pozosta³ych)
po³±czeñ z klientami (bo blisko <CODE>M * N</CODE>, gdzie
<CODE>N</CODE> - jest maksymaln± liczb± otwartych deskryptorów dla
jednego procesu, za¶ <CODE>M</CODE> - maksymaln± liczb± jednocze¶nie
dzia³aj±cych procesów jednego u¿ytkownika). Tak wysok± sprawno¶æ
uzyskali¶my dziêki przestawieniu ca³ej komunikacji (tj. tej z
klientami oraz tej miêdzy procesem-rodzicem a procesem-dzieckiem) na
po³±czenia nieblokuj±ce (asynchroniczne socket'y). Poza tym,
rodzielili¶my zadanie przyjmowania po³±czenia, które wykonuje
proces-ojciec oraz obs³ugê po³±czeñ HTTP, które wykonuj±
procesy-dzieci.

</P>

<A NAME="obiekty"></A>
<H4><LI>Model obiektowy</LI></H4>

<P>
<A HREF="oo/project__.Package.gif.html">GIF 3032x1386 [26K + 64K]</A>
</P>


<A NAME="klasy"></A>
<H4><LI>Opis zaprojektowanych klas</LI></H4>

<UL>

<P><LI><A HREF="doc/Exception.html">klasa <CODE><B>Exception</B></CODE></A> - obiekty tej klasy s±
<I>wyj±tkami</I> jêzyka C++ rzucanymi (jak
nazwa wskazuje) w sytacjach wyj±tkowych (np. niepowodzenia wywo³ania
funkcji systemowej). U³atwa to kontrolê sterowania programem oraz
generowania tre¶ciwych komunikatów o b³êdach i miejscach ich
wyst±pienia.
</LI></P>

<P><LI><A HREF="doc/SystemException.html">klasa <CODE><B>SystemException</B></CODE></A> - klasa pochodna klasy
<CODE>Exception</CODE> zapewniaj±ca dodatkowo komunikaty o b³êdach
pochodz±ce bezpo¶rednio od systemu operacyjnego (na podstawie
zmiennej <CODE>errno</CODE> i funkcji
<CODE>strerror</CODE>).
</LI></P>

<P><LI><A HREF="doc/EOFException.html">klasa <CODE><B>EOFException</B></CODE></A> - obiekt tej klasy jest
<I>wyj±tkiem</I> w sensie jêzyka <CODE>C++</CODE> rzucanym
w sytuacji, gdy za¿±dano odczytu z deskryptora dok³adnej porcji danych
(tzn. nie akceptowana jest porcja mniejsza), za¶
system operacyjny informuje, i¿ do czytania ju¿ nic wiêcej nie
ma.<BR>
Klasa dziedziczy publicznie po klasie <CODE>SystemException</CODE>.
</LI></P>

<P><LI><A HREF="doc/SString.html">klasa <CODE><B>SString</B></CODE></A> - obiekty tej klasy
u³atwiaj± operacje na ci±gach znaków, poprzez zdefiniowanie kilku
operatorów oraz posiadanie statycznego bufora o wielko¶ci 512 bajtów.
Potrafi± te¿ formatowaæ tekst tak jak czyni to np. funkcja
<CODE>sprintf</CODE>.<BR>
Wykorzystywana g³ównie przez klasy <CODE>Exception</CODE>,
<CODE>SystemException</CODE> i <CODE>EOFException</CODE>.
</LI></P>

<P><LI><A HREF="doc/Descriptor.html">klasa <CODE><B>Descriptor</B></CODE></A> - klasa ta obudowuje
klasyczne UNIXowe funkcje operuj±ce na deskryptorach w klasê jêzyka C++, by
upro¶ciæ korzystanie z nich, a jednocze¶nie zapewniæ lepsz± obs³ugê
sytuacji awaryjnych (niepowodzeñ wywo³añ tych¿e funkcji systemowych)
poprzez rzucanie wyj±tków jêzyka C++, a przez to u³atwienie
sterowania wykonywaniem programu. Metody tej klasy s± wspólne dla
plików jak i gniazd.
</LI></P>

<P><LI><A HREF="doc/File.html">klasa <CODE><B>File</B></CODE></A> - obiekty tej klasy to
standardowe pliki systemu UNIX<SMALL>&reg;</SMALL>.
Celem obudowania funkcji do obs³ugi plików w jedn±
klasê jest uproszczenie i uczynienie bardziej przejrzystym kodu
¼ród³owego.<BR>
Klasa dziedziczy publicznie klasê <CODE>Descriptor</CODE>. Zawiera
dodatkowe metody specyficzne dla plików, takie jak blokowanie pliku,
zmiana pozycji z której bêda czytane lub zapisywane dane, pobieranie
rozmiaru pliku, czy te¿ daty jego ostatniej modyfikacji.
</LI></P>

<P><LI><A HREF="doc/FileInfo.html">klasa <CODE><B>FileInfo</B></CODE></A> - obiekty tej klasy
zawieraj± informacje na temat istniej±cych plików takie jak: data
ostatniej modyfikacji i rozmiar. Klasa pozwala na
uzyskiwanie tych informacji bez otwierania wskazanego pliku.
</LI></P>

<P><LI><A HREF="doc/Socket.html">klasa <CODE><B>Socket</B></CODE></A> - obiekty tej klasy to
standardowe gniazda (socket'y) systemu UNIX<SMALL>&reg;</SMALL>.
Klasa rozszerza mo¿liwo¶ci klasy <CODE>Descriptor</CODE> o metody
specyficzne dla deskryptorów gniazd (takie jak: <CODE>connect</CODE>,
<CODE>bind</CODE>, <CODE>listen</CODE>, <CODE>accept</CODE>).
</LI></P>

<P><LI><A HREF="doc/AsyncSocket.html">klasa <CODE><B>AsyncSocket</B></CODE></A> - klasa ta,
dziedzicz±ca publicznie po klasie <CODE>Socket</CODE>, zmienia
wywo³ania niektórych jej metod, by poprawnie zachowywa³y siê dla
po³±czeñ asynchronicznych (nieblokuj±cych).
</LI></P>

<P><LI><A HREF="doc/AsyncMessageQueue.html">klasa <CODE><B>AsyncMessageQueue</B></CODE></A> - klasa ta
(dziedzicz±ca prywatnie klasê <CODE>AsyncSocket</CODE>) s³u¿y przede
wszystkim do komunikacji miêdzyprocesowej. Oprócz zwyk³ych danych
pozwala tak¿e przekazywaæ otwarte deskryptory plików i gniazd
(socketów) innym procesom. Ze wzglêdu na potrzeby tego projektu oraz
wymagane jej cechy
zosta³a ona zrealizowana na ³±czu komunikacyjnym nieblokuj±cym
(asynchronicznym socket'cie w dziedzinie UNIXa).
</LI></P>

<P><LI><A HREF="doc/AsyncConnection.html">klasa <CODE><B>AsyncConnection</B></CODE></A> - klasa ta jest
<I>interfejsem</I>, który musz± implementowaæ obiekty, które ¿ycz±
sobie byæ obs³ugiwane przez <CODE>ConnectionsManager</CODE>'a.
Zawiera wirtualne metody (w sensie jêzyka C++), które przykryte
przez klasy dziedzicz±ce tê klasê, zostan± wywo³ane, gdy zajd±
sprzyjaj±ce ku temu okoliczno¶ci, tj. gdy obiekt ten poinformuje, i¿
interesuje go np. zdarzenie &quot;mo¿liwo¶æ pisania na jego
deskryptorze&quot; i jednocze¶cie system operacyjny poinformuje
obiekt <CODE>ConnectionsManager</CODE> za pomoc± funkcji
<CODE>select</CODE>, ¿e taka mo¿liwo¶æ istnieje.
Innymi s³owy, za pomoc± klasy <CODE>AsyncConnection</CODE> i
<CODE>ConnectionsManager</CODE>, realizujemy <B>programowanie
zdarzeniowe</B>.
</LI></P>

<P><LI><A HREF="doc/ConnectionsManager.html">klasa <CODE><B>ConnectionsManager</B></CODE></A> - obiekt tej klasy
potrafi zarz±dzaæ grup± obiektów, które implementuj± interfejs
<CODE>AsyncConnection</CODE> i realizuj± nieblokuj±ce po³±czenie z
u¿yciem UNIXowych deskryptorów. Obiektowi tej klasy oddaje siê
sterowanie zarówno w procesie-rodzicu, jak i w procesach potomnych.
Dziêki klasie <CODE>AsyncConnection</CODE> metody z innych obiektów
mog± byæ wywo³ywane w odpowiednich dla nich momentach, tj. gdy zajd±
zdarzenia &quot;mo¿liwo¶æ pisania na deskryptorze&quot; lub/i
&quot;mo¿liwo¶æ czytania z deskryptora&quot. Obiekt tej klasy usuwa
zamkniête po³±czenia w sposób umo¿liwiaj±cy ich dalsze wykorzystanie
po re-inicjalizacji.
</LI></P>

<P><LI><A HREF="doc/HTTPConnection.html">klasa <CODE><B>HTTPConnection</B></CODE></A> - klasa
implementuj±ca interfejs <CODE>AsyncConnection</CODE> i realizuj±ca
po³±czenie z klientem (cze¶ci± obiektu <CODE>HTTPConnection</CODE> jest obiekt
<CODE>AsyncSocket</CODE>). Zajmuje siê tylko odbieraniem (i
zapamiêtywaniem) danych przes³anych od klienta, oraz wysy³aniem
odpowiedzi wygenerowanej przez obiekt <CODE>HTTPRequest</CODE>.
Obiekt tej klasy potrafi te¿ wys³aæ plik wskazany przez
<CODE>HTTPRequest</CODE>'a.<BR>
</LI></P>

<P><LI><A HREF="doc/HTTPRequest.html">klasa <CODE><B>HTTPRequest</B></CODE></A> - obiekt tej klasy
zajmuje siê parsowaniem zapytania klienta, zrozumieniem go oraz
wygenerowaniem w³a¶ciwej odpowiedzi (zgodnie z protoko³em HTTP).
Wskazuje te¿ oraz otwiera plik, którego wys³aniem zaj±æ siê ma obiekt
<CODE>HTTPConnection</CODE>.
</LI></P>

<P><LI><A HREF="doc/ResponseHeader.html">klasa <CODE><B>ResponseHeader</B></CODE></A> - prywatna klasa
klasy <CODE>HTTPRequest</CODE>. Jej obiekty s± nag³ówkami odpowiedzi
wysy³anymi do klientów. Atrybutami tych oiektów s±: kod odpowiedzi, jej krótki
opis, opis w HTMLu.
</LI></P>

<P><LI><A HREF="doc/ChildThread.html">klasa <CODE><B>ChildThread</B></CODE></A> - obiekt tej klasy
odpowiedzialny s± za przyjmowanie nowych po³±czeñ od procesu-rodzica,
tworzenie z nich obiektów <CODE>HTTPConnection</CODE>
i obs³ugê tych¿e.<BR>
Jego czê¶ci± jest obiekt <CODE>ConnectonsManager</CODE>, który
&quot;za³atwia ca³± robotê&quot; z po³±czeniami.<BR>
Klasa <CODE>ChildThread</CODE> implementuje interfejs <CODE>AsyncConnection</CODE>.
</LI></P>

<P><LI><A HREF="doc/ConnectionWithChild.html">klasa <CODE><B>ConnectionWithChild</B></CODE></A> - ka¿dy obiekt
tej klasy zajmuje siê komunikacj± miêdzy procesem-rodzicem
a jednym procesem-dzieckiem, po stronie procesu-ojca. Potrafi
przekazaæ dziecku nowe po³±czenie (deskryptor gniazda przekazany za
pomoc± obiektu <CODE>AsyncMessageQueue</CODE>, który jest jego
czê¶ci±) oraz odebraæ informacjê
o aktualnej ilo¶ci otwartych po³±czeñ procesu-dziecka. To on nie
pozwala, by proces-dziecko mia³o wiêksz± ni¿ dozwolona w pliku
konfiguracyjnym ilo¶æ jednocze¶nie otwartych po³±czeñ.<BR>
Klasa implementuje interfejs <CODE>AsyncConnection</CODE>.
</LI></P>

<P><LI><A HREF="doc/ParentThread.html">klasa <CODE><B>ParentThread</B></CODE></A> - obiekt tej klasy,
istniej±cy tylko w procesie-rodzica, odpowiedzialny jest za przyjmowanie nowych po³±czeñ
od klientów oraz przekazywanie ich procesom-dzieciom za pomoc±
obiektów <CODE>ConnectionWithChild</CODE>.<BR>
Klasa implementuje interfejs <CODE>AsyncConnection</CODE>, do obs³ugi
asynchronicznego gniazda po³±czeniowego, na którym nas³uchuje w
oczekiwaniu na nowe po³±czenia &quot;ze ¶wiata&quot;.
</LI></P>

<P><LI><A HREF="doc/Vector.html">klasa <CODE><B>Vector</B></CODE></A> - implementacja struktury danych
okre¶lanej jako dynamiczna tablica. Przechowuje wska¼niki do
&quot;czegokolwiek&quot; (<CODE>void *</CODE>). Po dostarczeniu jej
funkcji porównuj±cej potrafi sortowaæ oraz wyszukiwaæ po¿±dane
elementy.<BR>
Klasa potrzebna miêdzy innymi klasie <CODE>Properties</CODE>,
<CODE>ConnectionsManager</CODE> i <CODE>ChildThread</CODE>.
</LI></P>

<P><LI><A HREF="doc/Properties.html">klasa <CODE><B>Properties</B></CODE></A> - obiekty tej klasy
 potrafi± wczytaæ plik tekstowy zawieraj±cy pary
<CODE>klucz-warto¶æ</CODE> oraz zapamiêtaæ go tak (dziêki obiektowi
klasy <CODE>Vector</CODE>), by odszukiwanie danej warto¶ci na
podstawie podanego klucza odbywa³o siê szybko. Klasa ta rozpoznaje
linie komentarza rozpoczynaj±ce siê od znaku
&quot;<CODE>#</CODE>&quot;. Akceptuje odwrotn± kolejno¶æ w pliku tekstowym, a
tak¿e wiele kluczy dla jednej warto¶ci.<BR> Wykorzystana przede
wszystkim do wczytania pliku z <CODE>MimeTypes</CODE> oraz pliku
konfiguracyjnego dla tego daemona.
</LI></P>

<P><LI><A HREF="doc/PropertiesNode.html">klasa <CODE><B>PropertiesNode</B></CODE></A> - prywatna klasa
klasy <CODE>Properties</CODE> zapamiêtuj±ca (jako obiekty klasy
<CODE>String</CODE>) <CODE>klucz</CODE> i odpowiadaj±c± mu
<CODE>warto¶æ</CODE>.
</LI></P>

<P><LI><A HREF="doc/String.html">klasa <CODE><B>String</B></CODE></A> - klasa u³atwiaj±ce korzystanie z
danych z³o¿onych z ci±gów znaków. Podobna do klasy
<CODE>SString</CODE>, jednak tutaj bufor znakowy jest przydzielany
dynamicznie (<CODE>malloc</CODE>), za¶ jego wielko¶æ nieograniczona.<BR>
Potrzebna miêdzy innymi klasie <CODE>Properties</CODE>.
</LI></P>

<P><LI><A HREF="doc/Configuration.html">klasa <CODE><B>Configuration</B></CODE></A> - klasa dziedzicz±ca
prywatnie po klasie <CODE>Properties</CODE> a stworzona, by wygodniej
obs³ugiwaæ plik konfiguracyjny naszego daemona.
</LI></P>

</UL>



<A NAME="dzialanie"></A>
<H4><LI>Opis sposobu funkcjonowania oprogramowania</LI></H4>

<P>
<A NAME="conf"></A>
Po uruchomieniu program czyta swój <B>plik konfiguracyjny</B> o
nazwie <B><CODE>yhttpd.conf</CODE></B>, w którym zawarte
musz± byæ takie informacje:
</P>

<UL>
<LI>
<P>
<B><CODE>BindAddress</CODE></B> - adres <CODE>IP</CODE> na którym na nas³uchiwaæ.
W wiêkszo¶ci wypadków wystarczy <CODE>0.0.0.0</CODE>, co oznacza, ¿e pakiety przychodz±ce
na ka¿dy z posiadanych przez ten komputer interfejsów sieciowych maj±
byæ przekazywane naszemu procesowi (pod warunkiem oczywi¶cie, ¿e zgadza³
siê te¿ bêdzie numer portu - takimi rzeczami zajmuje siê jednak system
operacyjny).<BR>Je¶li chcemy natomiast odbieraæ po³±czenia tylko z
jednego adresu <CODE>IP</CODE>, to nale¿y go tu wpisaæ.</P></LI>

<LI><P>
<B><CODE>BindPort</CODE></B> - numer  portu na którym
nas³uchujemy.<BR>O ile nasz proces nie bêdzie
dzia³a³ z uprawnieniami nadzorcy systemu (<CODE>root</CODE>'a), to
numer portu musi byæ wiêkszy od 1024 i oczywi¶cie wolny.</P></LI>

<LI><P><B><CODE>HostName</CODE></B> - nazwa komputera w sieci (np.
<CODE>student.uci.agh.edu.pl</CODE>), potrzebna dla
odpowiedzi <CODE>HTTP</CODE> o kodzie <CODE>301 Moved Permanently</CODE> i pola
<CODE>Location</CODE> tej¿e odpowiedzi.</P></LI>

<LI><P><B><CODE>PidFile</CODE></B> - nazwa pliku (mo¿e byæ ze
¶cie¿k±) do którego zapisany zostanie <CODE>PID</CODE> procesu-ojca.
Wystarczy potem z linii poleceñ wpisaæ: <CODE>kill `cat yhttpd.pid`</CODE>
i proces (wraz ze swoimi dzieæmi) jest ju¿ ubity (je¶li
<CODE>yhttpd.pid</CODE>
by³ wskazanym plikiem).
</P></LI>

<LI><P><B><CODE>ErrorLog</CODE></B> - nazwa pliku (mo¿e byæ ze
¶cie¿k±) do którego zapisywane bêd± ewentualne komunikaty o b³êdach.
Konieczna ze wzglêdu na to, ¿e je¶li proces bêdzie dzia³a³ jak
prawdziwy demon, to naturalnie od³±czony bêdzie od jakiegokolwiek
terminala, tak wiêc komunikaty o b³êdach nie by³y by wy¶wietlone
nigdzie.
</P></LI>

<LI><P><B><CODE>DebugLog</CODE></B> - nazwa pliku (mo¿e byæ tak¿e ze
¶cie¿k±) do którego zapisywane bêd± ewentualne informacje o przebiegu
proramu. Bardzo u¿yteczne przy testowaniu (dla obszernych informacji
konieczne jest skompilowanie projektu z ustawionym
<CODE>define</CODE>'em <CODE>DEBUG</CODE>.
</P></LI>

<LI><P><B><CODE>Children</CODE></B> - ilo¶æ procesów-dzieci jak±
utworzyæ ma proces rodzic. Nie mo¿e przekroczyæ maksymalnej warto¶ci
narzucanej przez dany system operacyjny (je¶li tak siê stanie, to
demon siê nie uruchomi, a odpowiedni komuniakt znajdzie siê w pliku).
</P></LI>

<LI><P><B><CODE>MaxChildConnections</CODE></B> - maksymalna ilo¶æ
aktywnych po³±czeñ z klientami, które mo¿e obs³ugiwaæ jeden
proces-dziecko.
</P></LI>

<LI><P><B><CODE>ListenBacklog</CODE></B> - warto¶æ argumentu dla
funkcji systemowej <CODE>::listen</CODE>. Zwykle <CODE>150</CODE>.
</P></LI>

<LI><P><B><CODE>DocumentRoot</CODE></B> - bezwzglêdna ¶cie¿ka dostêpu do
g³ównego katalogu dokumentów <CODE>HTML</CODE>.
</P></LI>

<LI><P><B><CODE>UserDir</CODE></B> - ¶cie¿ka dostêpu wzglêdem
katalogów u¿ytkowników, do katalogu, w którym nale¿y spodziewaæ siê dokumentów <CODE>HTML</CODE>
u¿ytkowników (zwykle <CODE>public_html</CODE>).
</P></LI>

<LI><P><B><CODE>MimeTypesFile</CODE></B> - pe³na ¶cie¿ka dostêpu do
pliku <CODE>mime.types</CODE>.
</P></LI>
</UL>
A tak mo¿e wygl±daæ przyk³adowy plik <CODE>yhttpd.conf</CODE>:
<PRE>
BindAddress		0.0.0.0
BindPort		8000
HostName		student.uci.agh.edu.pl
PidFile			yhttpd.pid
ErrorLog		error.log
DebugLog		debug.log
Children		10
MaxChildConnections	100
ListenBacklog		150
DocumentRoot		/var/www/
UserDir			/public_html
# MimeTypesFile		/etc/mime.types
MimeTypesFile		/usr/local/apache/etc/mime.types
</PRE>

<P>
Po wczytaniu pliku konfiguracyjnego tworzone jest
gniazdo, na którym proces bêdzi nas³uchiwa³.<BR>
Nastêpnie
otwierane s± pliki wskazane w pliku konfiguracyjnym i zapisywane
informacje o czasie rozpoczêcia pracy. Proces-g³ówny (i jedyny na
razie) od³±cza siê od terminala (poprzez ustawienie obs³ugi
odpowiednich sygna³ów, przejêcie przywództwa grupy procesów i
podwójny <CODE>fork()</CODE>).
</P>

<P>
Nastêpnie tworzy ¿±dan± liczbê procesów potomnych, ustanawia z nimi
³±cza komunikacyjne i zaczyna oczekiwaæ na zg³oszenia od przegl±darek (klientów WWW).
</P>

<P>
Po przyjêciu po³±czenia przekazuje je do jednego ze swoich dzieci.
Proces który otrzyma³ zlecenie, spróbuje je wykonaæ: tzn. otworzy
wskazany plik, ustali jego typ i cechy (rozmiar, data ostatniej
modyfikacji) oraz ostatecznie wy¶le do klienta, je¶li kilent tego
¿±da³.
Je¶li która¶ z tych czynno¶ci nie powiedzie siê, zostanie
wygenerowany odpowiedni kod odpowiedzi i komentarz do zaistnia³ego b³êdu.
</P>

<P>
Nasz serwer obs³uguje zapytania: <CODE><B>GET</B></CODE>,
<CODE><B>HEAD</B></CODE> i <CODE><B>OPTIONS</B></CODE> oraz
nastêpuj±ce odpowiedzi:
</P>
<P>
<CENTER>
<TABLE BORDER="1" CELLPADDING="2" CELLSPACING="1">
<TR><TD ALIGN="CENTER"><B>&nbsp;kod&nbsp;</B></TD><TD ALIGN="CENTER"><B>&nbsp;znacznie&nbsp;</B></TD></TR>
<TR><TD>&nbsp;200 OK&nbsp;</TD><TD>&nbsp;wszystko w porz±dku&nbsp;</TD></TR>
<TR><TD>&nbsp;301 Moved Permanently&nbsp;</TD><TD>&nbsp;dokument przeniesiono&nbsp;</TD></TR>
<TR><TD>&nbsp;400 Bad Request&nbsp;</TD><TD>&nbsp;niepoprawne zapytanie&nbsp;</TD></TR>
<TR><TD>&nbsp;404 Not Found&nbsp;</TD><TD>&nbsp;dokumentu nie znaleziono&nbsp;</TD></TR>
<TR><TD>&nbsp;501 Method Not Implemented&nbsp;</TD><TD>&nbsp;zapytanie nieobs³ugiwane&nbsp;</TD></TR>
</TABLE>
</CENTER>
</P>



<A NAME="zmiany"></A>
<H4><LI>Zmiany w projekcie</LI></H4>
<P>
Jedyne zmiany jakie nast±pi³y wzglêdem pierwotnego projektu, dotycz±
zwiêkszenia ilo¶ci klas zaprojektowanych w czasie dokonywania
formalnej analizy obiektowej w stosunku do klas powsta³ych na etapie
projektowania obiektowego. Nast±pi³o to poprzez
</P>
<UL>

<LI>
<P>
generalizacjê ju¿ istniej±cych klas i wyodrêbnienie z nich klas,
które ³±cz± wspólne cechy pozosta³ych:<BR>
- z klas <CODE>File</CODE> i <CODE>Socket</CODE> wyodrêbniono klasê
<CODE>Descriptor</CODE>.
</P>
</LI>

<LI>
<P>
rozszerzenie mo¿liwo¶ci ju¿ istniej±cych klas i uogólnienie ich
przeznaczenia (wraz z ewentualn± zmian± ich nazwy):<BR>
- klasa <CODE>MimeTypes</CODE> zamieni³a siê w bardzo uniwersaln± klasê
<CODE>Properties</CODE>,<BR>
- klasa <CODE>SocketManager</CODE> w <CODE>ConnectionsManager</CODE>.
</P>
</LI>

<LI>
<P>
stworzenie ca³kiem nowych klas, których nie przewidziano w
pocz±tkowym projekcie, a które uzupe³niaj± funkcjonalno¶æ pozosta³ych
i czyni± projekt kompletnym obiektowo i &quot;zapiêtym na ostatni
guzik&quot; funkcjonalnie:<BR>
- klasy <CODE>AsyncSocket</CODE>, <CODE>AsyncMessageQueue</CODE>,
<CODE>ChildThread</CODE>, <CODE>ParentThread</CODE>
i interfejs <CODE>AsyncConnection</CODE>.
</P>
</LI>

<LI>
<P>
stworzenie klas, które mimo tego, ¿e ich istnienie jest w pe³ni
uzasadnione z punktu widzenia obiektowego, to powsta³y tylko dlatego,
by uczyniæ kod ¼ród³owy czytelniejszym a pracê programisty
wygodniejsz±.<BR>
- nale¿± do nich klasy <CODE>EOFException</CODE>, <CODE>SString</CODE>,
<CODE>Configuration</CODE>, <CODE>FileInfo</CODE>.
</P>
</LI>
</UL>

</OL>

<A NAME="implementacja"></A>
<H3><LI>Implementacja</LI></H3>

<OL>

<A NAME="kompatybilnosc"></A>
<H4><LI>Kompatybilno¶æ</LI></H4>

<P>
Projekt zosta³ zaimplementowany w jêzyku C++ z u¿yciem funkcji
nale¿±cych do standardu POSIX.<BR>Dlatego powinien siê kompilowaæ i
poprawnie dzia³aæ na wszelkich maszynach posiadaj±cych kompilator
tego jêzyka oraz przynajmniej czê¶ciow± kompatybilno¶æ ze wspomnianym
standardem (w zakresie przez nas wykorzystywanym). Obecno¶æ narzêdzia
<CODE>make</CODE> jest wskazana, lecz niekonieczna.
</P>

<A NAME="kompilacja"></A>
<H4><LI>Informacje o sposobie kompilacji</LI></H4>

<P>
By skompilowaæ demona, nale¿y z linii poleceñ wydaæ polecenie:
<PRE>
make
</PRE>
Kompilacja przebiega automatycznie. Program wykonywalny znajduje siê
w pliku <CODE><B>yhttpd</B></CODE> w tym samym katalogu, co jego
pliki ¼ród³owe.
</P>


<A NAME="podrecznik"></A>
<H4><LI>Podrêcznik u¿ytkownika</LI></H4>

<P>
Demona uruchamia siê wpisuj±c z linii poleceñ:
<PRE>
./yhttpd
</PRE>
lub z inn± scie¿k± dostêpu. W ka¿dym razie nie s± wymagane ¿adne
parametry. Wszelkie informacje potrzebne demonowi pobierane s± z
pliku konfiguracyjnego, którego szuka on z katalogu bie¿±cego (nie
musi to byæ ten sam katalog, z którego zosta³ on uruchomiony). Inne
pliki tworzy on w miejscach wskazanych w pliku konfiguracyjnym,
którego opis znajduje siê <A HREF="#conf">tutaj</A>.
</P>

<P>
Demon normalne nie koñczy swego dzia³ania, chyba, ¿e wydarzy siê co¶
z³ego lub te¿ odbierze on sygna³ sugeruj±cy mu zakoñczenie pracy. £atwym
sposobem na zabicie demona jest pos³u¿enie siê PIDem procesu-ojca,
który zapisany zostanie w pliku wskazanym w pliku konfiguracyjnym.
</P>


</OL>


<A NAME="podsumowanie"></A>
<H3><LI>Podsumowanie</LI></H3>

Wykonany przez nas projekt jest zgodny z tematem zadania oraz spe³nia
jego wszystkie za³o¿enia.<BR>

Podczas prac nad nim wykorzystali¶my wszystkie te cechy jêzyka C++,
jak i systemu UNIX&reg;, które pozwoli³y na osi±gniêcie du¿ej
wydajno¶ci i bezawaryjno¶ci pracy demona, przy jednoczesnym
zachowaniu przejrzysto¶ci kodu ¼ród³owego i wzglêdnej &quot;prostoty
koncepcyjnej&quot;.<BR>

Demon nasz zosta³ tak¿e gruntownie przetestowany - poprawnie
wspó³pracuje ze wszystkimi przegl±darkami WWW, do których uda³o siê
nam dotrzeæ.


</OL>

<P>
<HR>

<STRONG>
Kod ¼ród³owy tego programu oraz jego dokumentacja s± chronione przez
Ustawê o prawie autorskim i prawach pokrewnych. Nie mog± byæ u¿yte
ani opublikowane w ¿adnych innych pracach bez pisemnej zgody ich
autorów.
</P>

<P>
This documentation and all of the sources are copyright protected and
may not be used or published in other works without express written
permission from the authors.
</P>

</STRONG>

</BODY>
</HTML>
